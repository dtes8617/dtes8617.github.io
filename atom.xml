<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>隨談雜記</title>
  
  <subtitle>數據。程式。讀書筆記</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://dtes8617.github.io/"/>
  <updated>2018-06-16T08:27:19.931Z</updated>
  <id>https://dtes8617.github.io/</id>
  
  <author>
    <name>Jude Su</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Anaconda</title>
    <link href="https://dtes8617.github.io/2018/06/16/Anaconda/"/>
    <id>https://dtes8617.github.io/2018/06/16/Anaconda/</id>
    <published>2018-06-16T08:24:02.411Z</published>
    <updated>2018-06-16T08:27:19.931Z</updated>
    
    <content type="html"><![CDATA[<p>如果要做數據分析，安裝Anaconda是必要的步驟之一。主要原因是它包含分析過程中很多必要的套件跟工具，另外，不同的專案可以設定不同的環境，不會讓安裝在電腦上的套件相衝突，以達到版本控制的需求。</p><a id="more"></a><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><h3 id="管理套件"><a href="#管理套件" class="headerlink" title="管理套件"></a>管理套件</h3><p><code>conda list</code> 確認所有安裝的套件</p><p>更新Anaconda：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda upgrade conda</span><br><span class="line">conda upgrade -all</span><br></pre></td></tr></table></figure><p><code>conda install package_name</code> 安裝套件<code>package_name</code>，指定版本時可用<code>package_name = 1.10</code></p><p><code>conda remove packagez_name</code> 移除套件。</p><p><code>conda search &#39;*beautifulsoup*&#39;</code> 不確定套件名稱時，可以用模糊搜尋。</p><h3 id="管理環境"><a href="#管理環境" class="headerlink" title="管理環境"></a>管理環境</h3><p><code>conda create -n env_name list of packages</code> 用來創造環境，以及所需用到的套件。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create -n py3 python=3.6</span><br></pre></td></tr></table></figure><p><code>source activate my_env</code> 用來進入環境（for Mac)。</p><p><code>activate my_env</code> 用來進入環境（for Windows)。</p><p><code>source deactivate</code> 用來退出環境（for Mac)。</p><p><code>deactivate</code> 用來退出環境（for Windows)。</p><p><code>conda env list</code> 確認現有已建立的環境。最原始的環境名稱為<code>root</code>。</p><p><code>conda env remove -n env_name</code> 移除環境。</p><h4 id="分享環境"><a href="#分享環境" class="headerlink" title="分享環境"></a>分享環境</h4><p>Anaconda 有個非常有用的功能，就是能將環境輸出與別人分享。分享的格式以YAML呈現。</p><p><code>conda env export &gt; environment.yaml</code> 輸出環境，注意要在進入環境的情形下執行。</p><p><code>conda env create -f environment.yaml</code> 建立別人分享的環境。</p><p>一般來說，分享至Github上的專案都會建議將環境的YAML文件附上，讓其他人跟容易安裝專案所需要的套件。更完美的方式會將<code>pip</code>的環境文件<code>requirement.txt</code>一併附上，可以使用<code>pip freeze</code>來完成，如何使用可以參考<a href="https://pip.pypa.io/en/stable/reference/pip_freeze/" target="_blank" rel="noopener">這裡</a>。</p><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ol><li><a href="https://classroom.udacity.com/courses/ud1111" target="_blank" rel="noopener">Anaconda and Jupyter Notebooks</a></li><li><a href="https://jakevdp.github.io/blog/2016/08/25/conda-myths-and-misconceptions/" target="_blank" rel="noopener">Conda myths and misconceptions</a></li><li><a href="https://conda.io/docs/user-guide/tasks/index.html" target="_blank" rel="noopener">Conda documentation</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果要做數據分析，安裝Anaconda是必要的步驟之一。主要原因是它包含分析過程中很多必要的套件跟工具，另外，不同的專案可以設定不同的環境，不會讓安裝在電腦上的套件相衝突，以達到版本控制的需求。&lt;/p&gt;
    
    </summary>
    
      <category term="數據學堂" scheme="https://dtes8617.github.io/categories/%E6%95%B8%E6%93%9A%E5%AD%B8%E5%A0%82/"/>
    
    
      <category term="Python" scheme="https://dtes8617.github.io/tags/Python/"/>
    
      <category term="Anaconda" scheme="https://dtes8617.github.io/tags/Anaconda/"/>
    
  </entry>
  
  <entry>
    <title>Stepwise Selection for Dummy Variable</title>
    <link href="https://dtes8617.github.io/2018/04/30/Stepwise%20Selection%20for%20Dummy%20Variable/"/>
    <id>https://dtes8617.github.io/2018/04/30/Stepwise Selection for Dummy Variable/</id>
    <published>2018-04-29T16:43:11.797Z</published>
    <updated>2018-06-16T08:25:32.490Z</updated>
    
    <content type="html"><![CDATA[<p>在建迴歸模型時，為了在解釋力提升及過擬合間取得平衡，我們會挑選適切的變數出來。在R中有個很方便的函數<code>step</code>幫我們挑選，但如果資料集當中有類別變數超過三個類別時，挑選上會有一些問題。</p><a id="more"></a><p>舉例來說，假設一個變數X有三個類別A、B、C，轉換成factor後，R會以dummy variable來處理，分別為X_A及X_B。迴歸模型計算結果告訴我們X_A顯著但X_B不顯著。照理來說我們會排掉X_B再重新建一次模型，但<code>step</code>無法單純把X_B踢掉，他針對的是變數本身。因此要嘛就是X全部進入模型，要嘛就全出。</p><p>以下會更清楚的說明以及解決方式。</p><h2 id="問題說明"><a href="#問題說明" class="headerlink" title="問題說明"></a>問題說明</h2><p>現在有一個銀行的資料集，用來預測用戶離開銀行的原因。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glimpse(db)</span><br></pre></td></tr></table></figure><p><img src="https://www.dropbox.com/s/5idm4gvfimhp5g5/Screenshot%202018-04-30%2000.05.59.png?raw=1" alt="圖片"></p><p>其中變數Geography超過三個類別，分別為France、Spain、Germany。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">y &lt;- glm(Exited ~ ., data = dat, family = binomial())</span><br><span class="line">summary(y)</span><br></pre></td></tr></table></figure><p><img src="https://www.dropbox.com/s/ntf8q5kyoxg1gy0/Screenshot%202018-04-30%2000.30.40.png?raw=1" alt="圖片"></p><p>在Backward Elimination的方法中，Geography的Spain是需要排除的變數，但當我們使用<code>step</code>會發現狀況。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">z &lt;- step(y, direction = <span class="string">'backward'</span>)</span><br></pre></td></tr></table></figure><p><img src="https://www.dropbox.com/s/2v5qvho08ljuxda/Screenshot%202018-04-30%2000.37.26.png?raw=1" alt="圖片"></p><p>該方法只會針對Geography這個變數做篩選，並不會用Dummy Variable來處理。</p><h2 id="解決方式"><a href="#解決方式" class="headerlink" title="解決方式"></a>解決方式</h2><p>如果遇到這樣的問題，目前的方式還是老實的把變數轉換成Dummy Variable再做Stepwise Selection。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dat_dummy &lt;- fastDummies::dummy_cols(dat, select_columns = c(<span class="string">'Geography'</span>, <span class="string">'Gender'</span>), remove_first_dummy = <span class="literal">T</span>) %&gt;% </span><br><span class="line">  select(-Gender, -Geography)</span><br><span class="line">y_dummy &lt;- glm(Exited ~ ., data = dat_dummy, family = binomial())</span><br><span class="line"></span><br><span class="line">z_dummy &lt;- step(y_dummy, direction = <span class="string">'backward'</span>)</span><br><span class="line">summary(z_dummy)</span><br></pre></td></tr></table></figure><p><img src="https://www.dropbox.com/s/bc0wscrszvfsz2l/Screenshot%202018-04-30%2000.40.06.png?raw=1" alt="圖片"></p><p>這樣就能單獨處理多類別的變數了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在建迴歸模型時，為了在解釋力提升及過擬合間取得平衡，我們會挑選適切的變數出來。在R中有個很方便的函數&lt;code&gt;step&lt;/code&gt;幫我們挑選，但如果資料集當中有類別變數超過三個類別時，挑選上會有一些問題。&lt;/p&gt;
    
    </summary>
    
      <category term="數據學堂" scheme="https://dtes8617.github.io/categories/%E6%95%B8%E6%93%9A%E5%AD%B8%E5%A0%82/"/>
    
    
      <category term="Dummy Variable" scheme="https://dtes8617.github.io/tags/Dummy-Variable/"/>
    
      <category term="Stepwise Selection" scheme="https://dtes8617.github.io/tags/Stepwise-Selection/"/>
    
      <category term="R" scheme="https://dtes8617.github.io/tags/R/"/>
    
  </entry>
  
  <entry>
    <title>文字探勘 - 創造專屬字典</title>
    <link href="https://dtes8617.github.io/2018/02/10/%E6%96%87%E5%AD%97%E6%8E%A2%E5%8B%98%20-%20%E5%89%B5%E9%80%A0%E5%B0%88%E5%B1%AC%E5%AD%97%E5%85%B8/"/>
    <id>https://dtes8617.github.io/2018/02/10/文字探勘 - 創造專屬字典/</id>
    <published>2018-02-10T09:26:28.000Z</published>
    <updated>2018-06-16T08:25:39.146Z</updated>
    
    <content type="html"><![CDATA[<p>一般來說，我們在處理文字斷詞時可以直接使用像是<code>jieba</code>這類型的套件，因他已收集足夠豐富的字詞，所以斷字基本上不會有太大誤差。儘管是一些比較特殊的情境，像假如你要分析哈利波特小說的文字內容，或是魔戒的影評分析，網路上大多都有相對應的字典供你載入。但若你想分析的文章你苦苦找尋就是沒有找著字典，又或者是你想分析公司資料但特有的專業術語太多，這時候就得嘗試自己創造一個專有的字典。</p><a id="more"></a><p>你當然可以選擇將專有名詞一個一個填上去，但身為一個數據分析師，當然應該嘗試讓程式來幫我們完成囉！我參考了<a href="https://docs.google.com/presentation/d/1IP5vFmBlGPBp32bWDqSpGYLox5QVmenFAfPwcOseQhQ/edit#slide=id.g2704cd226_074" target="_blank" rel="noopener">陳嘉葳寫的推廣PPT</a>提供的方法，依步驟來動手完成這一隻程式。</p><h2 id="前置作業"><a href="#前置作業" class="headerlink" title="前置作業"></a>前置作業</h2><h3 id="分析資料"><a href="#分析資料" class="headerlink" title="分析資料"></a>分析資料</h3><p>我拿之前寫的一篇文章<a href="https://dtes8617.github.io/2018/02/01/淺談文字探勘%20-%20轉換非結構化文字/">淺談文字探勘 - 轉換非結構化文字</a>來做原始資料，當中包含文字探勘的一些專有名詞。同樣方法可應用在其他的文章或評論中，只是怕牽涉版權只好先拿自己的文章來玩玩。</p><h3 id="環境及套件"><a href="#環境及套件" class="headerlink" title="環境及套件"></a>環境及套件</h3><p>操作的環境如下所示：</p><blockquote><ul><li><strong>作業系統</strong>：macOS High Sierra</li><li><strong>程式語言</strong>：R version 3.4.3</li><li><strong>IDE</strong>：RStudio version 1.1.414</li></ul></blockquote><p>過程中所需用到的套件如下：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">library</span>(tidyverse)</span><br><span class="line"><span class="keyword">library</span>(stringr)</span><br><span class="line"><span class="keyword">library</span>(tm)</span><br><span class="line"><span class="keyword">library</span>(RWeka)</span><br><span class="line"><span class="keyword">library</span>(slam)</span><br><span class="line"><span class="keyword">library</span>(snowfall)</span><br></pre></td></tr></table></figure><p>因為需要做文字上的處理，<code>stringr</code>可以幫助我們在文字上做任意的轉換。<code>tm</code>主要是用來做文字探勘的一個套件，但他對中文的支援度很差，一般來說建議使用<code>tidytext</code>。不過在清理資料中的標點符號或是英文數字等，它有不錯的函數可以用，因此這裡也把它載入。<code>RWeka</code>是用來個別斷詞用的，下方會說明它的用途。<code>slam</code>則是因為文字的運算量相當龐大，過程中我們會轉換成matrix來做運算，這是可以使用這個套件會比較方便。<code>snowfall</code>也是運算龐大的原因，因此用平行運算的方式來加速結果產出。</p><h2 id="創建字典"><a href="#創建字典" class="headerlink" title="創建字典"></a>創建字典</h2><h3 id="資料處理"><a href="#資料處理" class="headerlink" title="資料處理"></a>資料處理</h3><p>這裡我直接將文章的內容儲存成.txt檔，以方便直接讀取。現在的目的是製作專屬字典，因此標點符號及數字不是我們需考量的東西（當然如果需要也可以將它們納進來），在資料處理時就將它們移除。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dat &lt;- read_lines(<span class="string">"./創建字典.txt"</span>)</span><br><span class="line">dat &lt;- paste0(dat, collapse = <span class="string">""</span>)</span><br><span class="line">dat &lt;- removePunctuation(dat, ucp = <span class="literal">T</span>) %&gt;% <span class="comment"># 去除全形標點符號</span></span><br><span class="line">  removePunctuation() %&gt;% <span class="comment"># 去除半形標點符號</span></span><br><span class="line">  removeNumbers() %&gt;% <span class="comment"># 去除數字</span></span><br><span class="line">  &#123;gsub(<span class="string">'[A-Za-z \\\t]'</span>, <span class="string">''</span>, .)&#125; <span class="comment"># 去除英文及跳脫符號\t</span></span><br></pre></td></tr></table></figure><p>在將它們處理成一整個文字塊後，我們要將它們分開斷詞，期望處理成以下的形式：</p><blockquote><p>“我們在分” “們在分析” “在分析時” “分析時都” “析時都習” “時都習慣” …</p><p>“我們在” “們在分” “在分析” “分析時” “析時都” “時都習” “都習慣” …</p><p>“我們” “們在” “在分” “分析” “析時” “時都” “都習” “習慣” …</p></blockquote><p>這樣就可以將有可能形成字詞的字斷開，再用一些方法將專有的字詞跳出來。這裡要注意的是，<code>NGramTokenizer</code>這個函式原來是為了拉丁語句做個別斷詞使用的，所以他對每一個字的斷詞判斷是以空格為主，因此我們用來處理中文時，就先將字與字之間加入空格，等斷完字再將空格移除。作法如下：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">full &lt;- dat %&gt;% str_split_fixed(<span class="string">""</span>, n = <span class="literal">Inf</span>)  %&gt;% </span><br><span class="line">  str_c(collapse = <span class="string">" "</span>) %&gt;%   <span class="comment"># 將字詞用空白分開</span></span><br><span class="line">  NGramTokenizer(Weka_control(min =<span class="number">2</span>, max = <span class="number">5</span>)) %&gt;% <span class="comment"># 重複斷詞</span></span><br><span class="line">  &#123;gsub(<span class="string">" "</span>,<span class="string">""</span>,.)&#125; %&gt;% <span class="comment"># 移除空格</span></span><br><span class="line">  data.frame(name = .) %&gt;% </span><br><span class="line">  count(name) %&gt;% <span class="comment"># 計算每個字詞出現次數</span></span><br><span class="line">  ungroup() %&gt;% </span><br><span class="line">  mutate(proportion = n / sum(n), name = parse_character(name)) <span class="comment"># 計算比例</span></span><br></pre></td></tr></table></figure><p>接下來我們將出現較少的字詞移除，一方面是字詞太少時我們很難判斷它是否為專有名詞，另一方面是我們需將無關緊要的雜訊給移除。至於移除的標準就見仁見智，也有人不是用次數而是用比例當門檻。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">seg_base &lt;- full %&gt;% filter(n &gt;= <span class="number">2</span>) <span class="comment"># 將出現次數較少的詞彙濾除</span></span><br></pre></td></tr></table></figure><h3 id="獨立字詞"><a href="#獨立字詞" class="headerlink" title="獨立字詞"></a>獨立字詞</h3><p>對於專有名詞來說，我們當然希望它能被完整的切出來，但跟專有名詞高關聯度的字詞很常會一起被切出來。像下面這樣：</p><blockquote><p>“做文字探勘” “在文字探勘”</p><p>”文字探勘時“ “文字探勘的”</p></blockquote><p>我們要如何將「做」、「在」、「時」、「的」等字眼去除呢？這裡可以用一些機率論的原理，舉例來說，「文字探勘」跟「做」應該是要被切分開的詞，那麼$P(文字探勘)$與$P(做)$就應該彼此獨立，也就是說，<br>$$<br>P(做文字探勘) = P(做)\times P(文字探勘)<br>$$<br>我們做個簡單的換位，<br>$$<br>k= \frac{P(做文字探勘)}{P(做)\times P(文字探勘)} \approx 1<br>$$<br>當近似於1時，代表「做文字探勘」不是一個獨立詞彙，那麼它就極有可能非專有名詞。仔細觀察可以發現，$k$越大作為一個字詞的可能性就越高，因此我們可以設置一個門檻，來濾除非我們想要的字詞。</p><p>因為母體的詞彙總數是相同的，所以這裡可以用次數來取代比率，會比較好計算。另外我們這裡只擷取四個字內的專有名詞，但切割需切割前後各一個字詞，這也是上面<code>NGramTokenizer</code>取5個字的原因。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 計算字詞的獨立關係</span></span><br><span class="line">segmentWord &lt;- <span class="keyword">function</span>(word, full)&#123; </span><br><span class="line">  n &lt;- nchar(word)-<span class="number">1</span> <span class="comment"># 切割位置數</span></span><br><span class="line">  seg &lt;- sapply(<span class="number">1</span>: n, <span class="keyword">function</span>(i)&#123; </span><br><span class="line">    w1 &lt;- substr(word, <span class="number">1</span>, i)</span><br><span class="line">    w2 &lt;- substr(word,i+<span class="number">1</span>, n+<span class="number">1</span>)</span><br><span class="line">    str_count(full, word) / (str_count(full, w1)*str_count(full,w2)) <span class="comment"># 計算佔比</span></span><br><span class="line">  &#125;)</span><br><span class="line">  seg_pro &lt;- min(parse_number(seg)) </span><br><span class="line">  <span class="keyword">return</span>(seg_pro)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">## 對獨立性判別較差的資料剔除</span></span><br><span class="line">commonword &lt;- sapply(seg_base$name, segmentWord, dat) %&gt;% data_frame(pro = .) %&gt;% </span><br><span class="line">  bind_cols(seg_base) %&gt;% </span><br><span class="line">  filter(pro &gt;= <span class="number">0.013</span>) <span class="comment"># 濾除未達門檻的詞彙</span></span><br></pre></td></tr></table></figure><h3 id="去除不完整的詞彙"><a href="#去除不完整的詞彙" class="headerlink" title="去除不完整的詞彙"></a>去除不完整的詞彙</h3><p>除了多餘的字詞來添亂，因為我們是個別斷詞的關係，零碎的字也會被抓進來。舉例來說：「文字探勘」會被斷出來，但是「文字探」或「字探勘」這類型的字一樣也會被抓出。為了解決這樣的問題，就引入了訊息量—「熵」這個概念。一個專有名詞周遭通常伴隨較豐富的訊息量，但像「文字探」後面通常只會加「勘」，所以訊息量就很低。所以只要抓住這個概念，只取兩側有豐富訊息量的字詞，就很有可能為專屬名詞。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">freq_all &lt;- matrix(full$proportion, dimnames = list(full$name))</span><br><span class="line">freq &lt;- matrix(commonword$proportion, dimnames = list(commonword$name))</span><br><span class="line"></span><br><span class="line">sfInit(parallel=<span class="literal">TRUE</span>, cpus=<span class="number">2</span>, type=<span class="string">"SOCK"</span>)</span><br><span class="line">shang &lt;- sfSapply(<span class="number">1</span>:length(freq), <span class="keyword">function</span>(x,y,z,zn)&#123;</span><br><span class="line">  restrict_name &lt;- zn[which(nchar(zn) &lt;= nchar(y[x])+<span class="number">1</span>)]</span><br><span class="line">  restrict &lt;- z[which(nchar(zn) &lt;= nchar(y[x])+<span class="number">1</span>)]</span><br><span class="line">  w1 &lt;- grep(paste(<span class="string">'^'</span>, y[x], sep=<span class="string">''</span>), restrict_name) <span class="comment"># 計算詞性後的可能性</span></span><br><span class="line">  pre &lt;- mean( -log2(restrict[w1])) <span class="comment"># 計算詞性後的訊息量</span></span><br><span class="line">  w2 &lt;- grep(paste(y[x], <span class="string">'$'</span>, sep=<span class="string">''</span>), restrict_name) <span class="comment"># 計算詞性前的可能性</span></span><br><span class="line">  post &lt;- mean( -log2(restrict[w2]) ) <span class="comment"># 計算詞性前的訊息量</span></span><br><span class="line">  <span class="keyword">return</span>( min(pre ,post) ) <span class="comment"># 回傳最小的訊息量</span></span><br><span class="line">&#125;, y = row.names(freq), z = freq_all, zn = row.names(freq_all))</span><br><span class="line">sfStop()</span><br><span class="line">names(shang) &lt;- row.names(freq)</span><br><span class="line">shang &lt;- shang[which(shang &gt;= <span class="number">12</span>)] <span class="comment"># Entropy要大於門檻entropy</span></span><br></pre></td></tr></table></figure><h2 id="結果產出"><a href="#結果產出" class="headerlink" title="結果產出"></a>結果產出</h2><p>廢話不多說，先來看看這樣產出後的結果：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">一向量</span><br><span class="line"><span class="number">12.64359</span></span><br><span class="line">下面</span><br><span class="line"><span class="number">12.64359</span></span><br><span class="line">不過</span><br><span class="line"><span class="number">12.64359</span></span><br><span class="line">主要</span><br><span class="line"><span class="number">12.64359</span></span><br><span class="line">之類</span><br><span class="line"><span class="number">12.64359</span></span><br><span class="line">也就是</span><br><span class="line"><span class="number">12.64359</span></span><br><span class="line">人會</span><br><span class="line"><span class="number">12.64359</span></span><br><span class="line">代表詞</span><br><span class="line"><span class="number">12.64359</span></span><br><span class="line">以及</span><br><span class="line"><span class="number">12.64359</span></span><br><span class="line">來判</span><br><span class="line"><span class="number">12.64359</span></span><br><span class="line">個詞彙在</span><br><span class="line"><span class="number">12.64359</span></span><br><span class="line">假設我們</span><br><span class="line"><span class="number">12.64359</span></span><br><span class="line">內容</span><br><span class="line"><span class="number">12.64359</span></span><br><span class="line">其他詞</span><br><span class="line"><span class="number">12.64359</span></span><br><span class="line"><span class="keyword">...</span></span><br></pre></td></tr></table></figure><p>可以看到雖然分出的字詞有些道理，但卻不那麼漂亮。這個原因在所準備的文字資料不夠大量所致，像「個詞彙在」這個詞，隨著「個」及「在」的比例增加，這個詞在<strong>獨立字詞</strong>階段就會被去除。所幸的是我們還是抓出了想要做成字典的字詞：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">向量指標</span><br><span class="line"><span class="number">12.64359</span></span><br><span class="line">搜尋引擎</span><br><span class="line"><span class="number">12.31254</span></span><br><span class="line">文件數</span><br><span class="line"><span class="number">12.64359</span></span><br><span class="line">文字探勘</span><br><span class="line"><span class="number">12.19647</span></span><br><span class="line">文章</span><br><span class="line"><span class="number">12.26832</span></span><br><span class="line">文章摘要</span><br><span class="line"><span class="number">12.64359</span></span><br></pre></td></tr></table></figure><h2 id="參考文章"><a href="#參考文章" class="headerlink" title="參考文章"></a>參考文章</h2><ol><li><a href="https://docs.google.com/presentation/d/1IP5vFmBlGPBp32bWDqSpGYLox5QVmenFAfPwcOseQhQ/edit#slide=id.g2704cd226_074" target="_blank" rel="noopener">R語言推廣講座Text Mining with R</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一般來說，我們在處理文字斷詞時可以直接使用像是&lt;code&gt;jieba&lt;/code&gt;這類型的套件，因他已收集足夠豐富的字詞，所以斷字基本上不會有太大誤差。儘管是一些比較特殊的情境，像假如你要分析哈利波特小說的文字內容，或是魔戒的影評分析，網路上大多都有相對應的字典供你載入。但若你想分析的文章你苦苦找尋就是沒有找著字典，又或者是你想分析公司資料但特有的專業術語太多，這時候就得嘗試自己創造一個專有的字典。&lt;/p&gt;
    
    </summary>
    
      <category term="數據學堂" scheme="https://dtes8617.github.io/categories/%E6%95%B8%E6%93%9A%E5%AD%B8%E5%A0%82/"/>
    
    
      <category term="R" scheme="https://dtes8617.github.io/tags/R/"/>
    
      <category term="Text Mining" scheme="https://dtes8617.github.io/tags/Text-Mining/"/>
    
  </entry>
  
  <entry>
    <title>淺談文字探勘 - 轉換非結構化文字</title>
    <link href="https://dtes8617.github.io/2018/02/01/%E6%B7%BA%E8%AB%87%E6%96%87%E5%AD%97%E6%8E%A2%E5%8B%98%20-%20%E8%BD%89%E6%8F%9B%E9%9D%9E%E7%B5%90%E6%A7%8B%E5%8C%96%E6%96%87%E5%AD%97/"/>
    <id>https://dtes8617.github.io/2018/02/01/淺談文字探勘 - 轉換非結構化文字/</id>
    <published>2018-01-31T16:59:06.298Z</published>
    <updated>2018-01-31T17:14:28.663Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://www.dropbox.com/s/tlmpaocd6ykv054/UNADJUSTEDNONRAW_thumb_e06.jpg?raw=1" alt="圖片"></p><p>我們在分析時，都習慣將資料整理成Tidy Data，以便我們建模來解釋或是預測所關注的事情。但在整理成Tidy Data之前，這些資料基本上都已經是結構化的。所以當我們試圖去分析文字、影像這種非結構化資料時，第一個會碰到的困難點就是如何將這些資料變成我們熟悉的結構化數據。凡通則必有例外，尤其是牽涉到人的時候，那大概只有例外這件事是通則了。與人貼身相關的語言就更不用說了，要能從千變萬化的語言中提煉出「結構化」的型態本身就不是一件容易的事。尤其《Ethnologue: Languages of the World》指稱語言在這世界上起碼有7,102種，即便是同一種語言隨時間、地點的不同也都可能各自發展，就像「擦子」跟「擦布」之類的。</p><a id="more"></a><p>那麼在提取結構化的文字資料之前，可能得先問問文字探勘想要做到的事情是什麼？最基本的不外乎就是從一段文字或一篇文章中，找到他真正想要表達的事情。我們可以看看下面的句子：</p><blockquote><p>我想在這裡表達的是，我過去學了很多東西，但我現在想要分享…欸…等等，我想要分享什麼？喔！對了！是那個嘛！就是文字探勘真的很有意思哦！你可以去學一下！</p></blockquote><p>先不要火大XD，我知道這句話很多贅字，讓人摸不著你到底想幹嘛。但這句話最重要的其實只有一句話，就是「文字探勘很有意思」。也就是說，只要我們能將這句話具代表性的詞彙標記出來，我們就能大略知道這句話到底想表達的意思是什麼。(雖然也是有很多話不明所以啦！)</p><p>那麼首先在文字探勘中，最首要的就是把字切出來。上面那段話我們可以切成下面這個樣子：</p><blockquote><p>“我”     “想”     “在”     “這裡”   “表達”   “的”     “是”     “我”     “過去”   “學”     “了”     “很多”   “東西”   “但”     “我”     “現在”   “想”     “要”     “分享”   “欸”     “等等”   “我”     “想”     “要”     “分享”   “什麼”   “喔”     “對了”  “是”     “那個”   “嘛”     “就”     “是”     “文字探勘”     “真的”   “很”     “有意思” “哦”     “你”     “可以”   “去”     “學”     “一下”</p></blockquote><p>將這些字按照出現次數排列之後，就可以形成以下表格：</p><table><thead><tr><th>詞彙</th><th>次數</th></tr></thead><tbody><tr><td>想</td><td>3</td></tr><tr><td>分享</td><td>2</td></tr><tr><td>學</td><td>2</td></tr><tr><td>一下</td><td>1</td></tr><tr><td>什麼</td><td>1</td></tr><tr><td>文字</td><td>1</td></tr><tr><td>去</td><td>1</td></tr><tr><td>有意思</td><td>1</td></tr><tr><td>那個</td><td>1</td></tr><tr><td>東西</td><td>1</td></tr><tr><td>表達</td><td>1</td></tr><tr><td>很</td><td>1</td></tr><tr><td>很多</td><td>1</td></tr><tr><td>真的</td><td>1</td></tr><tr><td><strong>文字探勘</strong></td><td>1</td></tr><tr><td>欸</td><td>1</td></tr><tr><td>現在</td><td>1</td></tr><tr><td>這裡</td><td>1</td></tr><tr><td>喔</td><td>1</td></tr><tr><td>過去</td><td>1</td></tr><tr><td>對了</td><td>1</td></tr></tbody></table><p>依「想」跟「分享」出現的頻率，就可以知道這段話到底有多想分享東西給別人了。不過仔細看會發現，我們剛剛認為最重要的「文字探勘」卻被排在相當後面。這段話若單純用次數來挖掘意義，就只會知道他想分享東西而已。所以關鍵在於，次數雖可以挖掘出一定的代表性，卻不見得能表達出整句話真正的含意。因此，另一個用來取代次數的方法就出來了，它也是現在搜尋引擎相當常用的方法 - <strong>TF-IDF(Term Frequency - Inverse Document Frequency)</strong></p><h2 id="TF-IDF"><a href="#TF-IDF" class="headerlink" title="TF-IDF"></a>TF-IDF</h2><p>在剛剛的例子中，我們知道「文字探勘」會是這句話的主軸，而不是「對了」、「欸」之類比較沒有意義的字。主要在於「文字探勘」在其他的文章或談話內容中，沒有「對了」或是「欸」這麼頻繁地出現。也因此一旦出現，就很容易成為那句話的焦點。所以我們要將「文字探勘」的重要性標記出來，單看這句話是不夠的。必須跟其他話語或文字做比較，才能知道「文字探勘」真的比較少出現。</p><p>假設我們比對了許多文章，將出現次數整理出以下表格：</p><table><thead><tr><th>詞彙</th><th>文章一</th><th>文章二</th><th>文章三</th><th>…</th></tr></thead><tbody><tr><td>對了</td><td>13</td><td>17</td><td>12</td><td>…</td></tr><tr><td>真的</td><td>14</td><td>17</td><td>13</td><td>…</td></tr><tr><td>文字探勘</td><td>7</td><td>0</td><td>0</td><td>…</td></tr></tbody></table><p>不難發現雖然「文字探勘」在<u>文章一</u>中出現的次數不及其他詞彙，但它跟其他文章比卻具有它的代表性在。順帶一提，這個表格所呈現的形式也就是文字探勘中常會用到的表格型態<a href="https://en.wikipedia.org/wiki/Document-term_matrix" target="_blank" rel="noopener">Term-Document Matrix</a>(TDM) 或是 它的轉置矩陣 Document-Term Matrix(DTM)。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>因此，在分析文件時，假設文件當成一向量$P$，而其可能出現的詞彙共有N種，則向量就可以表示成 $P = &lt; P_1, P_2 ,… , P_N &gt;$，其中 $P_i$ 就是個詞彙在這篇文章 $P$ 的權重。不過這 $P_i$應該要是什麼東西呢？有些人會用這個詞彙在文章中出現的<strong>次數</strong>作為權重，這種做法很直觀，但卻有一點不妥，如同剛剛所說，在這裡就不多做解釋。因此，TF-IDF考量詞彙在該文章中出現的頻率TF(Term Frequency)，以及詞彙在其他文章中出現的頻率IDF(Inverse Document Frequency)兩部分，TF代表 $P_i$在 $P$ 出現的頻率，可以表示成下列式子：</p><p>$$<br>tf_{(i,j)} = \frac{n_{i,j}}{\sum_kn_{k,j}}<br>$$<br>如同我們之前所說，$n_{i,j}$代表詞$t_i$在文件$d_j$出現的次數，而上述公式則代表詞組$t_i$跟其他詞組相比後的佔比是多少。而這僅能顯示他在文章中出現的次數，無法顯示這個詞組僅在這篇出現的獨特性。因此，引入了IDF來做考量的因子：<br>$$<br>idf_i = \log \frac{|D|}{|{j:t_i\in d_j}|}<br>$$<br>這個因子是考量總文件數$D$除以出現過詞$t_i$的文件數所得的商，再取對數。將文件的獨特性考量進來。而同時考量TF-IDF的指標，就出來了：<br>$$<br>tfidf_{i,j} = tf_{i,j} \times idf_i<br>$$</p><p>有了這個指標後，我們就可以利用文字雲的方式，將重要的詞彙呈現出來，也更能顯露出文章的特性。另一方面，在應用上的層面也較為廣泛。像現在的搜尋引擎很多都採用此種權重計算方式。</p><h3 id="應用"><a href="#應用" class="headerlink" title="應用"></a>應用</h3><h4 id="相似文件以及搜尋引擎"><a href="#相似文件以及搜尋引擎" class="headerlink" title="相似文件以及搜尋引擎"></a>相似文件以及搜尋引擎</h4><p>除了找出文章主要闡述的內容外，我們想找有相似主題的文章也可以利用此種方式。我們都學過線性代數，當中的內積很適合拿來作為相似與否的媒介。假設我們把目標文章的詞彙完整轉換成一個向量代表是 $p = &lt; p_1, p_2, …, p_n &gt;$，比對的文章則是 $q = &lt; q_1, q_2, …, q_n &gt;$，則可以透過角度大小來判斷兩向量是否接近，因 $\cos\theta = \frac{p\cdot q}{|p||q|}$，當 $\cos\theta$ 越接近1，則代表兩文章越相近。而這種評估方式也被稱作為<a href="https://en.wikipedia.org/wiki/Cosine_similarity" target="_blank" rel="noopener">Cosine Similarity</a>。</p><p>此種方式也很適合應用在搜尋引擎上，當我們使用<a href="https://zh.wikipedia.org/wiki/%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95" target="_blank" rel="noopener">倒排索引</a>來紀錄資料，可以輕鬆計算出每份文件中每個詞的TF-IDF指標，作為該文件的向量指標。便可進一步用$\cos\theta$來評估文件，並將搜尋的關鍵字作為一向量指標來判定最高相關的文章。</p><h4 id="關鍵字判別及文章摘要"><a href="#關鍵字判別及文章摘要" class="headerlink" title="關鍵字判別及文章摘要"></a>關鍵字判別及文章摘要</h4><p>除此之外，TF-IDF還可以應用在關鍵字的判定上，只要將該文章TF-IDF最高的前幾名挑出來，就可以自動生成文章的關鍵字詞組。不僅如此，還可應用在文章摘要，將文章內包含重要字詞的句子給挑出來。</p><h4 id="其他應用"><a href="#其他應用" class="headerlink" title="其他應用"></a>其他應用</h4><p>其實除了單純的意義提取外，這些結果都可以當作建立預測或解釋型模型很好的養分。譬如藉由爬蟲抓取PTT的資料，就可以關聯習慣逛那些文章類型的人會喜歡看什麼電影，藉此應用在電影推薦預測上。又或者是從文章找出企業跟時事的關聯，以作為投資股票的評估等等。在這個資訊爆炸的年代，已經不是只有人家準備好的結構化資料能夠拿來建模了，越孰悉將非結構化資料轉換成有用的資訊，就越能在這變動快速的時代抓緊先機。一起加油吧！</p><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ol><li><a href="https://www.ithome.com.tw/voice/90361" target="_blank" rel="noopener">從搜尋引擎到文字探勘</a></li><li><a href="https://kangliping.wordpress.com/2016/06/30/text-mining_text-analytics_tf-idf/" target="_blank" rel="noopener">文字探勘的快思慢想與遐想_Text Mining_Text Analytics_TF-IDF</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://www.dropbox.com/s/tlmpaocd6ykv054/UNADJUSTEDNONRAW_thumb_e06.jpg?raw=1&quot; alt=&quot;圖片&quot;&gt;&lt;/p&gt;
&lt;p&gt;我們在分析時，都習慣將資料整理成Tidy Data，以便我們建模來解釋或是預測所關注的事情。但在整理成Tidy Data之前，這些資料基本上都已經是結構化的。所以當我們試圖去分析文字、影像這種非結構化資料時，第一個會碰到的困難點就是如何將這些資料變成我們熟悉的結構化數據。凡通則必有例外，尤其是牽涉到人的時候，那大概只有例外這件事是通則了。與人貼身相關的語言就更不用說了，要能從千變萬化的語言中提煉出「結構化」的型態本身就不是一件容易的事。尤其《Ethnologue: Languages of the World》指稱語言在這世界上起碼有7,102種，即便是同一種語言隨時間、地點的不同也都可能各自發展，就像「擦子」跟「擦布」之類的。&lt;/p&gt;
    
    </summary>
    
      <category term="數據學堂" scheme="https://dtes8617.github.io/categories/%E6%95%B8%E6%93%9A%E5%AD%B8%E5%A0%82/"/>
    
    
      <category term="Text Mining" scheme="https://dtes8617.github.io/tags/Text-Mining/"/>
    
      <category term="TF-IDF" scheme="https://dtes8617.github.io/tags/TF-IDF/"/>
    
      <category term="TDM" scheme="https://dtes8617.github.io/tags/TDM/"/>
    
  </entry>
  
  <entry>
    <title>在Hexo顯示數學公式</title>
    <link href="https://dtes8617.github.io/2018/01/24/%E5%9C%A8Hexo%E9%A1%AF%E7%A4%BA%E6%95%B8%E5%AD%B8%E5%85%AC%E5%BC%8F/"/>
    <id>https://dtes8617.github.io/2018/01/24/在Hexo顯示數學公式/</id>
    <published>2018-01-24T15:53:58.319Z</published>
    <updated>2018-01-24T17:15:04.111Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://www.dropbox.com/s/4nbvxmorzx8ifvj/mathjax.svg?raw=1" alt="圖片"></p><p>由於Hexo本身沒有支援數學公式的顯示，因此即便在Markdown文件輸入數學公式，他也僅會顯示成<code>$\cos\theta = \frac{p\cdot q}{\|p\|\|q\|}$</code>這樣的形式，為了讓Hexo能正確顯示我們想呈現的數學字串$\cos\theta = \frac{p\cdot q}{|p||q|}$，我們需加入<code>mathJax</code>的插件。</p><a id="more"></a><h2 id="安裝mathJax"><a href="#安裝mathJax" class="headerlink" title="安裝mathJax"></a>安裝<code>mathJax</code></h2><p>安裝<code>mathJax</code>的方式相當簡單，只需在terminal中輸入下面指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install hexo-math --save</span></span><br></pre></td></tr></table></figure><p>接下來在Hexo中的<code>_config.yml</code>裡新增以下指令：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">math:</span></span><br><span class="line"><span class="attr">  engine:</span> <span class="string">'mathjax'</span> <span class="comment"># or 'katex'</span></span><br><span class="line"><span class="attr">  mathjax:</span></span><br><span class="line">    <span class="comment"># src: custom_mathjax_source</span></span><br><span class="line"><span class="attr">    config:</span></span><br><span class="line">      <span class="comment"># MathJax config</span></span><br></pre></td></tr></table></figure><p>並在主題的<code>_config.yml</code>下開啟<code>mathJax</code>的功能：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># MathJax Support</span></span><br><span class="line"><span class="attr">mathjax:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  per_page:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># cdn: //cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML</span></span><br><span class="line"><span class="attr">  cdn:</span> <span class="string">//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML</span></span><br></pre></td></tr></table></figure><p>由於每次讀取文章時皆會載入這個套件，過多數學公式有可能造成文章讀取速度變慢。因此若想要在特定文章開啟這個功能，可以做一些調配。由於我使用的是Next的主題，這裡以Next的方式做說明。首先先確認<code>themes/next/layout/_layout.swig</code>有沒有將<code>mathjsx.swig</code>引入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% include &apos;_third-party/mathjax.swig&apos; %&#125;</span><br></pre></td></tr></table></figure><p>若沒有請自行將上述指令放入文件中。之後找到<code>themes/next/layout/_third-party/mathjax.swig</code>，裡面的原本內容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if theme.mathjax.enable %&#125;</span><br><span class="line">  &#123;% if not theme.mathjax.per_page or (page.total or page.mathjax) %&#125;</span><br><span class="line">    &lt;script type=&quot;text/x-mathjax-config&quot;&gt;</span><br><span class="line">      MathJax.Hub.Config(&#123;</span><br><span class="line">        tex2jax: &#123;</span><br><span class="line">          inlineMath: [ [&apos;$&apos;,&apos;$&apos;], [&quot;\\(&quot;,&quot;\\)&quot;]  ],</span><br><span class="line">          processEscapes: true,</span><br><span class="line">          skipTags: [&apos;script&apos;, &apos;noscript&apos;, &apos;style&apos;, &apos;textarea&apos;, &apos;pre&apos;, &apos;code&apos;]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script type=&quot;text/x-mathjax-config&quot;&gt;</span><br><span class="line">      MathJax.Hub.Queue(function() &#123;</span><br><span class="line">        var all = MathJax.Hub.getAllJax(), i;</span><br><span class="line">        for (i=0; i &lt; all.length; i += 1) &#123;</span><br><span class="line">          all[i].SourceElement().parentNode.className += &apos; has-jax&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot; src=&quot;&#123;&#123; theme.mathjax.cdn &#125;&#125;&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p>將之改為：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if page.mathjax %&#125;</span><br><span class="line">  &lt;script type=&quot;text/x-mathjax-config&quot;&gt;</span><br><span class="line">    MathJax.Hub.Config(&#123;</span><br><span class="line">      tex2jax: &#123;</span><br><span class="line">        inlineMath: [ [&apos;$&apos;,&apos;$&apos;], [&quot;\\(&quot;,&quot;\\)&quot;]  ],</span><br><span class="line">        processEscapes: true,</span><br><span class="line">        skipTags: [&apos;script&apos;, &apos;noscript&apos;, &apos;style&apos;, &apos;textarea&apos;, &apos;pre&apos;, &apos;code&apos;]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">  &lt;script type=&quot;text/x-mathjax-config&quot;&gt;</span><br><span class="line">    MathJax.Hub.Queue(function() &#123;</span><br><span class="line">      var all = MathJax.Hub.getAllJax(), i;</span><br><span class="line">      for (i=0; i &lt; all.length; i += 1) &#123;</span><br><span class="line">        all[i].SourceElement().parentNode.className += &apos; has-jax&apos;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">  &lt;script type=&quot;text/javascript&quot; src=&quot;&#123;&#123; theme.mathjax.cdn &#125;&#125;&quot;&gt;&lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p>基本上這樣就大功告成了，之後在寫文章時，只要在front-matter中掛載插件<code>mathjax: true</code>即可：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 在Hexo顯示數學公式</span><br><span class="line">tags:</span><br><span class="line"><span class="bullet">- </span>Hexo</span><br><span class="line">categories:</span><br><span class="line"><span class="bullet">- </span>程式那點事</span><br><span class="line">mathjax: true</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>然而，只是安裝插件有些數學符號可能無法正確顯示，主要原因是跟Hexo的渲染引擎有關係。拿下標舉例，在Latex用下標是使用下底線<code>_</code>，但Markdown的斜體或粗體也是用下底線<code>_斜體_</code>，當數學式出現很多下標時，Hexo渲染就會把它優先轉成html形式。為了解決這個問題，我們須對Hexo的渲染做一些處理。</p><h2 id="更改Hexo渲染設定"><a href="#更改Hexo渲染設定" class="headerlink" title="更改Hexo渲染設定"></a>更改Hexo渲染設定</h2><p>網路上有許多資料及做法，因原Hexo渲染插件為<code>hexo-renderer-marked</code>，有些方式會將此插件改為其他支援<code>mathJax</code>的插件，但許多做法我使用後沒有效果，不然就是要改變書寫markdown的方式，所以最後還是決定修改渲染引擎的<code>js</code>腳本。不過此方法也有它的缺點，其一是換一次電腦就必須變更一次設定，其二是原來使用底線做斜體的配置會失效，不過對於第二點可以使用*取代，倒也不是太大的問題。</p><p>更改方式不是太困難，找到<code>node_modules\marked\lib\marked.js</code>，將裡面的第451行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">escape</span>: <span class="regexp">/^\\([\\`*&#123;&#125;\[\]()# +\-.!_&gt;])/</span>,</span><br></pre></td></tr></table></figure><p>更改為：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">escape</span>: <span class="regexp">/^\\([`*\[\]()# +\-.!_&gt;])/</span>,</span><br></pre></td></tr></table></figure><p>此步驟將原本<code>\\</code>轉換為<code>\</code>的轉譯取消。再找到459行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">em: <span class="regexp">/^\b_((?:[^_]|__)+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/</span>,</span><br></pre></td></tr></table></figure><p>更改為：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">em:<span class="regexp">/^\*((?:\*\*|[\s\S])+?)\*(?!\*)/</span>,</span><br></pre></td></tr></table></figure><p>這樣就把底線斜體取消了。到此應該就能完整呈現數學公式囉！好好享受吧！</p><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ol><li><a href="http://stevenshi.me/2017/06/26/hexo-insert-formula/" target="_blank" rel="noopener">hexo中插入数学公式</a></li><li><a href="http://masikkk.com/article/hexo-13-MathJax/" target="_blank" rel="noopener">Hexo博客(13)添加MathJax数学公式渲染</a></li><li><a href="http://www.nyansama.cn/2016/10/13/002/" target="_blank" rel="noopener">Hexo 使用 Mathjax</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://www.dropbox.com/s/4nbvxmorzx8ifvj/mathjax.svg?raw=1&quot; alt=&quot;圖片&quot;&gt;&lt;/p&gt;
&lt;p&gt;由於Hexo本身沒有支援數學公式的顯示，因此即便在Markdown文件輸入數學公式，他也僅會顯示成&lt;code&gt;$\cos\theta = \frac{p\cdot q}{\|p\|\|q\|}$&lt;/code&gt;這樣的形式，為了讓Hexo能正確顯示我們想呈現的數學字串$\cos\theta = \frac{p\cdot q}{|p||q|}$，我們需加入&lt;code&gt;mathJax&lt;/code&gt;的插件。&lt;/p&gt;
    
    </summary>
    
      <category term="程式那點事" scheme="https://dtes8617.github.io/categories/%E7%A8%8B%E5%BC%8F%E9%82%A3%E9%BB%9E%E4%BA%8B/"/>
    
    
      <category term="Hexo" scheme="https://dtes8617.github.io/tags/Hexo/"/>
    
      <category term="MathJax" scheme="https://dtes8617.github.io/tags/MathJax/"/>
    
  </entry>
  
  <entry>
    <title>用Hexo打造你的專屬Blog</title>
    <link href="https://dtes8617.github.io/2018/01/16/%E7%94%A8Hexo%E6%89%93%E9%80%A0%E4%BD%A0%E7%9A%84%E5%B0%88%E5%B1%ACBlog/"/>
    <id>https://dtes8617.github.io/2018/01/16/用Hexo打造你的專屬Blog/</id>
    <published>2018-01-15T19:02:21.989Z</published>
    <updated>2018-01-15T19:16:30.170Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://www.dropbox.com/s/1n3neygfv1epo89/Hexo.png?raw=1" alt="Hexo"></p><p>還記得最後寫網誌已經是大學的事了，那時候還是無名小站稱霸的年代。對於這麼久沒接觸Blog的我來說，需求也已經跟以往相差甚遠了。因為主要是記錄我的學習心得，所以一定要包含：</p><ul><li>漂亮的呈現程式碼及數學公式</li><li>不要有廣告</li><li>不用網路也可以撰寫或排版</li><li>簡單俐落的風格</li></ul><p>在尋尋覓覓後，我總算找到了<a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a>這個平台。在很多的Blog中都可以發現它的身影，厲害的是它的作者<a href="https://zespia.tw/blog/2012/10/11/hexo-debut/" target="_blank" rel="noopener">Tommy Chen</a>竟然是台灣人，大家可以去看看他一手打造的心路歷程。</p><p>由於我僅對R及Matlab的語法較熟悉，大學雖然有修過一點系統程式，但也年代久遠，所以在打造這個Blog花了我不少時間。我會將我架設的過程盡可能完整的寫出來，方便讓跟我一樣沒什麼基礎的人可以直接上手！</p><a id="more"></a><h2 id="初期準備"><a href="#初期準備" class="headerlink" title="初期準備"></a>初期準備</h2><p>如果你之前沒有碰過一些程式語言，在使用Hexo當Blog前就必須先有心理準備，會一定程度上接觸程式語法。不過倒也是不用太擔心，一方面是佈置的語法不難；另一方面是等架設好之後，除非想大改整個佈置，不然不用在碰太難的程式語言。首先，此Blog是架設在以下環境：</p><blockquote><ul><li><strong>作業系統</strong>：macOS High Sierra</li><li><strong>編譯器</strong>：VScode</li><li><strong>Markdown編輯器</strong>：Typora</li></ul></blockquote><p>雖然是用mac來操作，但在Windows上差異也不會太大。如沒有以上軟體，現在可以安裝，因為我們會使用這些軟體逐步實現我們的Blog，當然如果你有比較習慣的編譯器或Markdown編輯器，也可以使用自己上手的。</p><h3 id="編譯器設置（使用VScode"><a href="#編譯器設置（使用VScode" class="headerlink" title="編譯器設置（使用VScode)"></a>編譯器設置（使用VScode)</h3><p><img src="https://www.dropbox.com/s/s5brypq9wingk4m/Screenshot%202018-01-12%2023.49.29.png?raw=1" alt="圖片"></p><p>VScode會是後續整理Hexo的一個主要平台，它本身是一個編譯器，被定義在「Editor以上，IDE未滿」。也因此想要什麼功能都可以彈性調整，譬如說程式碼的高亮或是專案功能等等。詳細的VScode部署網上已有很多教學與討論，這裡就只說Hexo會用到的功能。先按 <code>^`</code> 開啟Terminal，mac本身的shell使用的是bash，但他沒有npm的指令，因此我們換個shell先，改成zsh及他的架構oh-my-zsh。</p><p>為了方便安裝，那就一定得要把<a href="https://brew.sh/index_zh-tw.html" target="_blank" rel="noopener">Homebrew</a>掛上。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> /usr/bin/ruby -e <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>"</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> brew install wget</span></span><br></pre></td></tr></table></figure><p>安裝zsh及補全功能。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> brew install zsh zsh-completions</span></span><br></pre></td></tr></table></figure><p>將shell從bash轉換為zsh。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> chsh -s /bin/zsh</span></span><br></pre></td></tr></table></figure><p>重新啟動後，就可以開始著手安裝Hexo了。如果你想讓Terminal的介面好看一點，可以參考此<a href="https://pjchender.blogspot.tw/2017/02/mac-terminal-iterm-2-oh-my-zsh.html" target="_blank" rel="noopener">網誌</a>的設置，內容相當詳盡。</p><h2 id="打造個人Hexo"><a href="#打造個人Hexo" class="headerlink" title="打造個人Hexo"></a>打造個人Hexo</h2><h3 id="安裝Hexo"><a href="#安裝Hexo" class="headerlink" title="安裝Hexo"></a>安裝Hexo</h3><p>查看<a href="https://hexo.io/zh-tw/docs/" target="_blank" rel="noopener">官網</a>就可以知道其實安裝過程相當簡單，只不過在安裝前必須先把Git及Node.js裝上。好在剛剛裝上了zsh及Homebrew，現在就非常方便了。</p><p>用Terminal來安裝Git，輸入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install git</span><br></pre></td></tr></table></figure><p>再來用wget安裝Node.js，先輸入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.2/install.sh | bash</span></span><br></pre></td></tr></table></figure><p>執行完後重新啟動Terminal，先安裝nvm，並輸入以下指令安裝Node.js：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> brew install nvm</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> nvm install stable</span></span><br></pre></td></tr></table></figure><p>接下來就可以安裝Hexo囉！只要輸入以下指令即可安裝：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install -g hexo-cli</span></span><br></pre></td></tr></table></figure><h3 id="建構Blog"><a href="#建構Blog" class="headerlink" title="建構Blog"></a>建構Blog</h3><p>在安裝完Hexo之後，緊接著就是來建構個人的Blog了，這裡我們就將要管理的目錄取名叫<code>Blog</code>，而建構的方式只要輸入下列指令即可完成：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo init Blog</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> Blog</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install</span></span><br></pre></td></tr></table></figure><p>建好的Blog資料夾中可以發現以下的資料夾</p><p><img src="https://www.dropbox.com/s/vvstgebb1rl1wn0/Screenshot%202018-01-14%2000.18.03.png?raw=1" alt="圖片"></p><p>其中幾個比較主要的文件可以留意一下：</p><ul><li><code>_config.yml</code>：Blog的主要設定文件，會經常使用到。</li><li><code>themes</code>：不想使用預設的畫面，想用別人設計好的主題就可以放裡面。</li><li><code>source</code>：網頁的內容像是文章，或是標籤、分類等都在這。</li></ul><p>到這一步其實就已經建構好了你的Blog，迫不及待想看看初步雛形可以輸入以下指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo server</span></span><br></pre></td></tr></table></figure><p>他會出現下列指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure><p>點選連結後就可以看到你的Blog了。這個指令在之後把網頁部署到Github後相當有用，如果網頁有新文章，或是有做一些套件的增加之類的修改時，可以先用這個指令看看成果，再決定要不要上傳。</p><h3 id="美化Blog"><a href="#美化Blog" class="headerlink" title="美化Blog"></a>美化Blog</h3><h4 id="變換主題"><a href="#變換主題" class="headerlink" title="變換主題"></a>變換主題</h4><p>如果你跟我一樣美術天份很差，或是懶得一步一步去修改Blog的介面，可以使用別人已經架好的樣板。官網就有許多<a href="https://hexo.io/themes/" target="_blank" rel="noopener">主題</a>可以讓你選擇。我使用的是NexT的主題，就先以這個主題來說明。點選名字後可以進入該主題的Github，基本上下面都會有說明文件。以NexT來說，安裝只要輸入以下指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir themes/next</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl -s https://api.github.com/repos/iissnan/hexo-theme-next/releases/latest | grep tarball_url | cut -d <span class="string">'"'</span> -f 4 | wget -i - -O- | tar -zx -C themes/next --strip-components=1</span></span><br></pre></td></tr></table></figure><p>你可以在<code>themes</code>裡發現多了<code>next</code>主題的資料夾，這代表NexT已經安裝好了。接下來就是把Blog的主題切換成NexT就好了。找到<code>Blog</code>下的<code>_config.yml</code>去修改以下內容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">next</span> <span class="comment"># 把這裡改成你的主題名稱</span></span><br></pre></td></tr></table></figure><p>這是應該就可以看到你的Blog已經換成不同的樣子了。如果想要變換更多設定，譬如說讓目錄列表從左邊改到右邊這種，可以看該主題在Github提供的說明文件，會有更詳盡的說明。</p><h4 id="訪問量"><a href="#訪問量" class="headerlink" title="訪問量"></a>訪問量</h4><p>這篇文章標題底下可以看到有多少人看過這篇文章，另外在頁面最下方也可以看到訪問這個Blog的人次。而要加入這樣的計算功能，有兩種管道，一是<a href="http://busuanzi.ibruce.info" target="_blank" rel="noopener">不蒜子</a>，但不蒜子的文章統計要點進文章裡才看得到，如果想在首頁就顯示文章閱讀量，則可以選擇<a href="https://leancloud.cn" target="_blank" rel="noopener">LeanCloud</a>。</p><h5 id="不蒜子"><a href="#不蒜子" class="headerlink" title="不蒜子"></a>不蒜子</h5><p>不蒜子的安裝方式相當簡單，指令都是放入<code>themes/你的主题/layout/_partial/footer.ejs</code>的文件中。因為需要安裝腳本，把以下指令放在文件的最前端。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script async src=&quot;//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>其中<code>src</code>後面的網址是不蒜子提供的，如你擔心這個腳本失效，也是可以將腳本載下來放在自己的雲端，將路徑改向自己的空間即可。</p><p>站點訪問量分成兩種，一種是站點訪問次數(pv)，如果同一人逛了五次網站，記數會顯示5；另一種則是站點訪客數(uv)，上述情形記數只會顯示1。看個人喜好去做選擇。將以下指令放入文件內，自己在調整位置即可。</p><p><u><strong>pv</strong></u></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;span id=&quot;busuanzi_container_site_pv&quot;&gt;</span><br><span class="line">    本站訪問量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次</span><br><span class="line">&lt;/span&gt;</span><br></pre></td></tr></table></figure><p><u><strong>uv</strong></u></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt;</span><br><span class="line">本站訪客數&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人次</span><br><span class="line">&lt;/span&gt;</span><br></pre></td></tr></table></figure><h5 id="LeanCloud"><a href="#LeanCloud" class="headerlink" title="LeanCloud"></a>LeanCloud</h5><p>由於我希望首頁即可看到文章瀏覽量，所以文章的記數我是採用LeanCloud來做。只不過這種方法相對於不蒜子來說就稍稍麻煩一些。先到官網註冊帳號，完成後點擊畫面中的創建應用。</p><p><img src="https://www.dropbox.com/s/hq0s2c25cdztdvg/Screenshot%202018-01-16%2000.51.42.png?raw=1" alt="圖片"></p><p>在新應用名稱輸入你想要的名字，完成創建，之後點擊進入設定。在存儲中創建Class，名稱務必輸入<code>Counter</code>，並在設置數據條目的默認中選擇無限制。</p><p><img src="https://www.dropbox.com/s/2bbyo6hi94hdo5h/Screenshot%202018-01-16%2000.54.41.png?raw=1" alt="圖片"></p><p>現在點選左邊的設置，進入「應用Key」應該可以看到「App ID」及「App Key」，這時可以填入Blog中<code>themes</code>下的<code>_config.yml</code>文件裡了。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Show number of visitors to each article.</span></span><br><span class="line"><span class="comment"># You can visit https://leancloud.cn get AppID and AppKey.</span></span><br><span class="line"><span class="attr">leancloud_visitors:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  app_id:</span> <span class="comment"># 你的App ID</span></span><br><span class="line"><span class="attr">  app_key:</span> <span class="comment"># 你的App Key</span></span><br></pre></td></tr></table></figure><p>這樣基本上計數就大功告成了，如果擔心計數被亂用，也可以到LeanCloud設置的安全中心加入自己的網域。</p><h4 id="評論系統"><a href="#評論系統" class="headerlink" title="評論系統"></a>評論系統</h4><p>評論系統的管道有很多，我自己是使用<a href="https://disqus.com/" target="_blank" rel="noopener">disqus</a>。在註冊之後，點選首頁的Get Started，再選擇下面的「I want to install Disqus on my site」，之後照著程序走即可，唯一要注意的是Website Name所設定的名稱，會配置在主題文件下的<code>_config.yml</code>中，完整修改如下。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Disqus</span></span><br><span class="line"><span class="attr">disqus:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  shortname:</span><span class="comment"># 你的Website Name</span></span><br><span class="line"><span class="attr">  count:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>值得注意的是，如果你有開啟Tag跟Categories的配置，那麼評論系統在這些畫面的預設是開啟的。如果不想要評論出現在這些頁面中，可以到Hexo中的<code>source/tag/index.md</code>修改成以下指令。（<code>categories</code>也是一樣做法）</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">date: 2018-01-08 19:24:44</span><br><span class="line">type: "tags"</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h3 id="部署到Github吧"><a href="#部署到Github吧" class="headerlink" title="部署到Github吧"></a>部署到Github吧</h3><p>費了一番苦心，總算把Blog整理成想要的樣子了吧！剩下最後一哩路，就是把你的Blog丟到網路上讓大家瞧瞧吧！</p><h4 id="連結Github"><a href="#連結Github" class="headerlink" title="連結Github"></a>連結Github</h4><p>首先到<a href="https://github.com" target="_blank" rel="noopener">Github</a>去創建一個repository，並且將它取名為<code>你的帳號.github.io</code>，進入這個repository的設定，找到GitHub Pages，選擇master branch，然後儲存。</p><p><img src="https://www.dropbox.com/s/7rw1xe7pr4bejt8/Screenshot%202018-01-16%2002.00.17.png?raw=1" alt="圖片"></p><p>回到主目錄，點選Hexo主目錄的<code>_config.yml</code>中，指令如下。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">  repo:</span> <span class="string">git@github.com:你的帳號/你的帳號.github.io.git</span></span><br><span class="line"><span class="attr">  branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>之後只要在Terminal輸入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d -g</span><br></pre></td></tr></table></figure><p>就可以在 <em><u><a href="https://你的帳號.github.io/" target="_blank" rel="noopener">https://你的帳號.github.io/</a></u></em> 看到你的Blog囉！</p><h4 id="免輸入密碼"><a href="#免輸入密碼" class="headerlink" title="免輸入密碼"></a>免輸入密碼</h4><p>為了不要每次部署都要輸入密碼，可以藉由創建SSH Key來達成。首先在Terminal輸入以下指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh-keygen -t rsa -C <span class="string">"your_email@example.com"</span></span></span><br></pre></td></tr></table></figure><p>他會出現</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/c/Users/you/.ssh/id_rsa): [Press enter]</span><br></pre></td></tr></table></figure><p>按下return後出現</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Enter passphrase (empty for no passphrase): </span><br><span class="line">Enter same passphrase again:</span><br></pre></td></tr></table></figure><p>接連按下return跳過passphrase的輸入，而後輸入一下指令將SSH密鑰複製起來。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> pbcopy &lt; ~/.ssh/id_rsa.pub</span></span><br></pre></td></tr></table></figure><p>到Github的Settings中，</p><p><img src="https://www.dropbox.com/s/13uogsi0oxwakea/Screenshot%202018-01-16%2002.28.24.png?raw=1" alt="圖片"></p><p>點選SSH and GPG keys，點擊NewSSH Key，Title可以隨便輸入，只要將剛剛複製的東西貼到key裡面就好。為了測試有沒有成功，到Terminal輸入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh -T git@github.com</span></span><br></pre></td></tr></table></figure><p>他會出現</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The authenticity of host 'github.com (207.97.227.239)' can't be established.</span><br><span class="line">RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)?</span><br></pre></td></tr></table></figure><p>輸入<code>yes</code>後，如果看到以下畫面，就代表你成功了！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hi username! You've successfully authenticated, but GitHub does not</span><br><span class="line">provide shell access.</span><br></pre></td></tr></table></figure><p>接下來就輸入下列指令來設定帳號資訊吧。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.name <span class="string">"yourusername"</span>   <span class="comment"># 你的帳號</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.email  <span class="string">"your_email@example.com"</span>   <span class="comment">#你的Email</span></span></span><br></pre></td></tr></table></figure><p>基本上到這裡就可以開始你的記錄旅程囉！好好享受吧！</p><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ol><li><p><a href="https://pjchender.blogspot.tw/2017/02/mac-terminal-iterm-2-oh-my-zsh.html" target="_blank" rel="noopener">為 MAC 的 Terminal 上色 - 透過 iTerm 2 和 Oh My Zsh 高亮你的終端機</a></p></li><li><p><a href="http://lodur46.blogspot.tw/2016/04/hexo-github.html" target="_blank" rel="noopener">使用 Hexo + Github 建立個人網誌</a></p></li><li><p><a href="https://www.jianshu.com/p/702a7aec4d00" target="_blank" rel="noopener">Hexo搭建博客系列：（五）Hexo添加不蒜子和LeanCloud统计无标题文章</a></p></li><li><p><a href="https://www.jianshu.com/p/d68de067ea74" target="_blank" rel="noopener">Hexo搭建博客系列：（六）Hexo添加Disqus评论</a></p><p>​</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://www.dropbox.com/s/1n3neygfv1epo89/Hexo.png?raw=1&quot; alt=&quot;Hexo&quot;&gt;&lt;/p&gt;
&lt;p&gt;還記得最後寫網誌已經是大學的事了，那時候還是無名小站稱霸的年代。對於這麼久沒接觸Blog的我來說，需求也已經跟以往相差甚遠了。因為主要是記錄我的學習心得，所以一定要包含：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;漂亮的呈現程式碼及數學公式&lt;/li&gt;
&lt;li&gt;不要有廣告&lt;/li&gt;
&lt;li&gt;不用網路也可以撰寫或排版&lt;/li&gt;
&lt;li&gt;簡單俐落的風格&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在尋尋覓覓後，我總算找到了&lt;a href=&quot;https://hexo.io&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;這個平台。在很多的Blog中都可以發現它的身影，厲害的是它的作者&lt;a href=&quot;https://zespia.tw/blog/2012/10/11/hexo-debut/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Tommy Chen&lt;/a&gt;竟然是台灣人，大家可以去看看他一手打造的心路歷程。&lt;/p&gt;
&lt;p&gt;由於我僅對R及Matlab的語法較熟悉，大學雖然有修過一點系統程式，但也年代久遠，所以在打造這個Blog花了我不少時間。我會將我架設的過程盡可能完整的寫出來，方便讓跟我一樣沒什麼基礎的人可以直接上手！&lt;/p&gt;
    
    </summary>
    
      <category term="程式那點事" scheme="https://dtes8617.github.io/categories/%E7%A8%8B%E5%BC%8F%E9%82%A3%E9%BB%9E%E4%BA%8B/"/>
    
    
      <category term="Hexo" scheme="https://dtes8617.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>個人Blog開張啦！</title>
    <link href="https://dtes8617.github.io/2018/01/01/%E5%80%8B%E4%BA%BABlog%E9%96%8B%E5%BC%B5%E5%95%A6%EF%BC%81/"/>
    <id>https://dtes8617.github.io/2018/01/01/個人Blog開張啦！/</id>
    <published>2018-01-01T15:02:00.000Z</published>
    <updated>2018-01-24T17:09:05.284Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://www.dropbox.com/s/vngbtvjt959mbhl/UNADJUSTEDNONRAW_thumb_633.jpg?raw=1" alt="圖片"></p><p>一直以來都有在做筆記的習慣，只是以往都是放在OneNote, Evernote之類的比較多。隨著吸收得知識越來越多，漸漸了解到有一個自己的Blog來經營還是重要的。倒也不是要給誰看，就算是我自己的一個成長歷程吧！</p><p>我是數學背景出身，碩士轉工業工程，主要研究隨機最佳化的領域。也因為這樣的經歷，讓我對<em><strong>用數學的方法解決現實問題</strong></em> 很感興趣，順理成章就往數據分析師這條路走下去。只是這條路畢竟是新的領域，不足的地方還太多，雖然一路上程式的底子還過得去，但畢竟不是資工背景。機器學習、深度學習就是要讓機器去挖掘一些我們尚不可見的資訊，那麼不懂機器又怎麼可以呢？</p><p>所以這個部落格的走向也就很明顯了，它不會只是我用來記錄數據分析領域的地方，當然還囊括了程式語言、網頁設計甚至是讀書心得等等的內容。就讓我們拭目以待吧！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://www.dropbox.com/s/vngbtvjt959mbhl/UNADJUSTEDNONRAW_thumb_633.jpg?raw=1&quot; alt=&quot;圖片&quot;&gt;&lt;/p&gt;
&lt;p&gt;一直以來都有在做筆記的習慣，只是以往都是放在OneNote,
      
    
    </summary>
    
    
  </entry>
  
</feed>
